{"entries":[{"timestamp":1761299772631,"editorVersion":"8.0.17","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":1,"length1":5830,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":235,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1761299927397,"editorVersion":"8.0.17","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3406,"length1":0,"diffs":[[1,"/////////////////////\n//#################//\n//##             ##//\n//##  eradio.ts  ##//\n//##             ##//\n//#################//\n/////////////////////\n"]]},{"start1":3561,"length1":0,"diffs":[[1,"let ID = \"ID\"\nlet IDLEN = 2\nlet MSGEND = \"#EOM#\"\nlet bsyids: string[] = []\nlet rdymsgs: string[] = []\nlet bsymsgs: string[] = []\n"]]},{"start1":3691,"length1":0,"diffs":[[1,"type readhandler = () => void\nlet readHandler: readhandler\n\nlet cnt = 0\n\nradio.onReceivedString(function (msg: string) {\n    cnt += 1\n    basic.showNumber(cnt)\n    let id = msg.substr(0, IDLEN)\n    msg = msg.substr(IDLEN)\n    let ix = 0\n    for (; ix < bsyids.length; ix++) {\n        if (id == bsyids[ix]) break\n    }\n    if (ix == bsyids.length) {\n        bsyids.push(id)\n        bsymsgs.push(\"\") // is handled at the end by 'bsymsgs[ix] += msg'\n    }\n    if (msg == MSGEND) { // end of message\n        rdymsgs.push(bsymsgs[ix])\n        bsymsgs.removeAt(ix)\n        bsyids.removeAt(ix)\n        if (readHandler) readHandler()\n        basic.showIcon(IconNames.Yes)\n        cnt = 0\n        return\n    }\n    bsymsgs[ix] += msg\n})\n\nnamespace ERadio {\n\n    export function readMessage(): string {\n        let msg = rdymsgs.shift()\n        return msg\n    }\n\n    export function writeMessage(msg: string) {\n        let chnk: string\n        let msglen = 18 - IDLEN\n        do {\n            chnk = msg.substr(0, msglen)\n            msg = msg.substr(msglen)\n            radio.sendString(ID + chnk)\n            basic.pause(1)\n        } while (msg.length > 0)\n        radio.sendString(ID + MSGEND)\n    }\n\n    // for senders \n    export function setId(id: string) {\n        ID = id\n        IDLEN = id.length\n    }\n\n    // for receivers only\n    export function setIdLength(length: number) {\n        IDLEN = length\n    }\n}\n\n\n"]]}]}]},{"timestamp":1761303559132,"editorVersion":"8.0.17","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3406,"length1":154,"diffs":[[1,""]]},{"start1":3407,"length1":120,"diffs":[[1,""]]},{"start1":3408,"length1":1747,"diffs":[[1,""]]}]}]},{"timestamp":1761303559870,"editorVersion":"8.0.17","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":118,"length1":111,"diffs":[[1,"        \"microphone\": \"*\"\n"]]}]}]},{"timestamp":1761303788292,"editorVersion":"8.0.17","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3972,"length1":5,"diffs":[[1,"\n"]]}]}]},{"timestamp":1761304422296,"editorVersion":"8.0.17","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3972,"length1":4,"diffs":[[1,"bsic\n"]]}]}]},{"timestamp":1761304422340,"editorVersion":"8.0.17","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3972,"length1":1,"diffs":[[1,"bsi\n"]]},{"start1":4018,"length1":24,"diffs":[[1,""]]},{"start1":4076,"length1":21,"diffs":[[1,""]]},{"start1":4104,"length1":22,"diffs":[[1,""]]},{"start1":4231,"length1":32,"diffs":[[1,""]]}]}]},{"timestamp":1761304671421,"editorVersion":"8.0.17","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4015,"length1":0,"diffs":[[1,"basic.showNumber(idlen)\n"]]},{"start1":4097,"length1":0,"diffs":[[1,"basic.showString(id)\n"]]},{"start1":4146,"length1":0,"diffs":[[1,"basic.showString(msg)\n"]]},{"start1":4295,"length1":0,"diffs":[[1,"basic.showIcon(IconNames.Happy)\n"]]}]}]},{"timestamp":1761305448614,"editorVersion":"8.0.17","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":5284,"length1":62,"diffs":[[1,""]]}]}]},{"timestamp":1761306321546,"editorVersion":"8.0.17","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":5346,"length1":0,"diffs":[[1,"        radio.sendString(RADIOID + MSGEND)\n"]]}]}]},{"timestamp":1761306613495,"editorVersion":"8.0.17","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":5798,"length1":80,"diffs":[[1,""]]},{"start1":5848,"length1":50,"diffs":[[1,"        str = ESerial.read()\n"]]},{"start1":5896,"length1":37,"diffs":[[1,"} while (str != \"READY\")\n"]]}]}]},{"timestamp":1761307148955,"editorVersion":"8.0.17","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":237,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":320,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests gaan hier; deze zal niet worden gecompileerd wanneer dit pakket wordt gebruikt als extensie.\n"}]}],"snapshots":[{"timestamp":1761299772630,"editorVersion":"8.0.17","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"greenbox-iot\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1761303559132,"editorVersion":"8.0.17","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n//////////////////////\n//##################//\n//##              ##//\n//##  eserial.ts  ##//\n//##              ##//\n//##################//\n//////////////////////\n\nlet g_init = false\nlet g_read: string[]\nlet g_write: string[]\ng_read = []\ng_write = []\nlet g_read_tmo = 0\nlet g_write_tmo = 0\n\nlet g_tx_dat: DigitalPin\t// tx out data\nlet g_tx_rdy: DigitalPin\t// tx out data valid\nlet g_tx_rcv: DigitalPin\t// tx in  data received\nlet g_rx_dat: DigitalPin\t// rx in  data\nlet g_rx_rdy: DigitalPin\t// rx in  data valid\nlet g_rx_rcv: DigitalPin\t// rx out data received\n\nfunction initESerial() {\n    pins.digitalWritePin(g_tx_rdy, 0)\n    pins.digitalWritePin(g_tx_rdy, 0)\n    pins.digitalWritePin(g_tx_rdy, 0)\n    g_read = []\n    g_write = []\n}\n\nfunction writeChar(char: string) {\n    let ch = char.charCodeAt(0)\n    let pin: number\n    for (let i = 0; i < 8; i++) {\n        pin = (ch & (1 << i))\n        pins.digitalWritePin(g_tx_dat, pin == 0 ? 0 : 1)\n        pins.digitalWritePin(g_tx_rdy, 1)\n        while (!pins.digitalReadPin(g_tx_rcv)) {\n            if (control.millis() > g_write_tmo) { initESerial(); return; }\n        }\n        pins.digitalWritePin(g_tx_rdy, 0)\n        while (pins.digitalReadPin(g_tx_rcv)) {\n            if (control.millis() > g_write_tmo) { initESerial(); return; }\n        }\n    }\n}\n\nfunction readChar(): string {\n    let pin: number\n    let ch = 0\n    for (let i = 0; i < 8; i++) {\n        while (!pins.digitalReadPin(g_rx_rdy)) {\n            if (control.millis() > g_read_tmo) { initESerial(); return \"\"; }\n        }\n        pin = pins.digitalReadPin(g_rx_dat)\n        ch |= (pin << i)\n        pins.digitalWritePin(g_rx_rcv, 1)\n        while (pins.digitalReadPin(g_rx_rdy)) {\n            if (control.millis() > g_read_tmo) { initESerial(); return \"\"; }\n        }\n        pins.digitalWritePin(g_rx_rcv, 0)\n    }\n    let ret = (ch == 0 ? \"\" : String.fromCharCode(ch))\n    return ret\n}\n\n// write strings\nbasic.forever(function () {\n    if (!g_init) return;\n    if (g_write.length > 0) {\n        g_write_tmo = control.millis() + 5000\n        let str = g_write.shift()\n        for (let i = 0; i < str.length; i++) {\n            if (control.millis() > g_write_tmo) { initESerial(); break; }\n            writeChar(str[i])\n        }\n        writeChar(String.fromCharCode(0))\n    }\n})\n\n// read strings\nbasic.forever(function () {\n    if (!g_init) return;\n    let str = \"\"\n    let ch = \"\"\n    if ((pins.digitalReadPin(g_rx_rdy) == 1)) { // available\n        g_read_tmo = control.millis() + 5000\n        do {\n            ch = readChar()\n            str += ch\n        } while (!ch.isEmpty())\n        if (control.millis() <= g_read_tmo)\n            g_read.push(str)\n        str = \"\"\n    }\n})\n\nnamespace ESerial {\n\n    export function setPins(tx_dat: DigitalPin,\n        tx_rdy: DigitalPin,\n        tx_rcv: DigitalPin,\n        rx_dat: DigitalPin,\n        rx_rdy: DigitalPin,\n        rx_rcv: DigitalPin) {\n        g_tx_dat = tx_dat\n        g_tx_rdy = tx_rdy\n        g_tx_rcv = tx_rcv\n        g_rx_dat = rx_dat\n        g_rx_rdy = rx_rdy\n        g_rx_rcv = rx_rcv\n\n        initESerial()\n        g_init = true\n    }\n\n    export function available(): boolean {\n        return (g_read.length > 0)\n    }\n\n    export function write(str: string) {\n        g_write.push(str)\n    }\n\n    export function read(): string {\n        if (g_read.length)\n            return g_read.shift()\n        return \"\"\n    }\n}\n\n\n/////////////////////\n//#################//\n//##             ##//\n//##  eradio.ts  ##//\n//##             ##//\n//#################//\n/////////////////////\n\nlet ID = \"ID\"\nlet IDLEN = 2\nlet MSGEND = \"#EOM#\"\nlet bsyids: string[] = []\nlet rdymsgs: string[] = []\nlet bsymsgs: string[] = []\n\ntype readhandler = () => void\nlet readHandler: readhandler\n\nlet cnt = 0\n\nradio.onReceivedString(function (msg: string) {\n    cnt += 1\n    basic.showNumber(cnt)\n    let id = msg.substr(0, IDLEN)\n    msg = msg.substr(IDLEN)\n    let ix = 0\n    for (; ix < bsyids.length; ix++) {\n        if (id == bsyids[ix]) break\n    }\n    if (ix == bsyids.length) {\n        bsyids.push(id)\n        bsymsgs.push(\"\") // is handled at the end by 'bsymsgs[ix] += msg'\n    }\n    if (msg == MSGEND) { // end of message\n        rdymsgs.push(bsymsgs[ix])\n        bsymsgs.removeAt(ix)\n        bsyids.removeAt(ix)\n        if (readHandler) readHandler()\n        basic.showIcon(IconNames.Yes)\n        cnt = 0\n        return\n    }\n    bsymsgs[ix] += msg\n})\n\nnamespace ERadio {\n\n    export function readMessage(): string {\n        let msg = rdymsgs.shift()\n        return msg\n    }\n\n    export function writeMessage(msg: string) {\n        let chnk: string\n        let msglen = 18 - IDLEN\n        do {\n            chnk = msg.substr(0, msglen)\n            msg = msg.substr(msglen)\n            radio.sendString(ID + chnk)\n            basic.pause(1)\n        } while (msg.length > 0)\n        radio.sendString(ID + MSGEND)\n    }\n\n    // for senders \n    export function setId(id: string) {\n        ID = id\n        IDLEN = id.length\n    }\n\n    // for receivers only\n    export function setIdLength(length: number) {\n        IDLEN = length\n    }\n}\n\n\n///////////////////////////\n//#######################//\n//##                   ##//\n//##  greenbox-iot.ts  ##//\n//##                   ##//\n//#######################//\n///////////////////////////\n\nESerial.setPins(\n    DigitalPin.P9,\n    DigitalPin.P12,\n    DigitalPin.P13,\n    DigitalPin.P14,\n    DigitalPin.P15,\n    DigitalPin.P16\n)\n\n// initialize\n\nlet str: string\ndo {\n    if (ESerial.available())\n        str = ESerial.read()\n    basic.pause(1)\n} while (str != \"READY\")\nbasic.showIcon(IconNames.Heart)\n\n// handle messages\n\nreadHandler = () => {\n    let msg = ERadio.readMessage()\n    if (msg.length > 0) {\n        basic.showIcon(IconNames.SmallHeart)\n        ESerial.write(msg)\n        basic.showIcon(IconNames.Heart)\n    }\n}\n","README.md":"","pxt.json":"{\n    \"name\": \"greenbox-iot\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1761305448614,"editorVersion":"8.0.17","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n//////////////////////\n//##################//\n//##              ##//\n//##  eserial.ts  ##//\n//##              ##//\n//##################//\n//////////////////////\n\nlet g_init = false\nlet g_read: string[]\nlet g_write: string[]\ng_read = []\ng_write = []\nlet g_read_tmo = 0\nlet g_write_tmo = 0\n\nlet g_tx_dat: DigitalPin\t// tx out data\nlet g_tx_rdy: DigitalPin\t// tx out data valid\nlet g_tx_rcv: DigitalPin\t// tx in  data received\nlet g_rx_dat: DigitalPin\t// rx in  data\nlet g_rx_rdy: DigitalPin\t// rx in  data valid\nlet g_rx_rcv: DigitalPin\t// rx out data received\n\nfunction initESerial() {\n    pins.digitalWritePin(g_tx_rdy, 0)\n    pins.digitalWritePin(g_tx_rdy, 0)\n    pins.digitalWritePin(g_tx_rdy, 0)\n    g_read = []\n    g_write = []\n}\n\nfunction writeChar(char: string) {\n    let ch = char.charCodeAt(0)\n    let pin: number\n    for (let i = 0; i < 8; i++) {\n        pin = (ch & (1 << i))\n        pins.digitalWritePin(g_tx_dat, pin == 0 ? 0 : 1)\n        pins.digitalWritePin(g_tx_rdy, 1)\n        while (!pins.digitalReadPin(g_tx_rcv)) {\n            if (control.millis() > g_write_tmo) { initESerial(); return; }\n        }\n        pins.digitalWritePin(g_tx_rdy, 0)\n        while (pins.digitalReadPin(g_tx_rcv)) {\n            if (control.millis() > g_write_tmo) { initESerial(); return; }\n        }\n    }\n}\n\nfunction readChar(): string {\n    let pin: number\n    let ch = 0\n    for (let i = 0; i < 8; i++) {\n        while (!pins.digitalReadPin(g_rx_rdy)) {\n            if (control.millis() > g_read_tmo) { initESerial(); return \"\"; }\n        }\n        pin = pins.digitalReadPin(g_rx_dat)\n        ch |= (pin << i)\n        pins.digitalWritePin(g_rx_rcv, 1)\n        while (pins.digitalReadPin(g_rx_rdy)) {\n            if (control.millis() > g_read_tmo) { initESerial(); return \"\"; }\n        }\n        pins.digitalWritePin(g_rx_rcv, 0)\n    }\n    let ret = (ch == 0 ? \"\" : String.fromCharCode(ch))\n    return ret\n}\n\n// write strings\nbasic.forever(function () {\n    if (!g_init) return;\n    if (g_write.length > 0) {\n        g_write_tmo = control.millis() + 5000\n        let str = g_write.shift()\n        for (let i = 0; i < str.length; i++) {\n            if (control.millis() > g_write_tmo) { initESerial(); break; }\n            writeChar(str[i])\n        }\n        writeChar(String.fromCharCode(0))\n    }\n})\n\n// read strings\nbasic.forever(function () {\n    if (!g_init) return;\n    let str = \"\"\n    let ch = \"\"\n    if ((pins.digitalReadPin(g_rx_rdy) == 1)) { // available\n        g_read_tmo = control.millis() + 5000\n        do {\n            ch = readChar()\n            str += ch\n        } while (!ch.isEmpty())\n        if (control.millis() <= g_read_tmo)\n            g_read.push(str)\n        str = \"\"\n    }\n})\n\nnamespace ESerial {\n\n    export function setPins(tx_dat: DigitalPin,\n        tx_rdy: DigitalPin,\n        tx_rcv: DigitalPin,\n        rx_dat: DigitalPin,\n        rx_rdy: DigitalPin,\n        rx_rcv: DigitalPin) {\n        g_tx_dat = tx_dat\n        g_tx_rdy = tx_rdy\n        g_tx_rcv = tx_rcv\n        g_rx_dat = rx_dat\n        g_rx_rdy = rx_rdy\n        g_rx_rcv = rx_rcv\n\n        initESerial()\n        g_init = true\n    }\n\n    export function available(): boolean {\n        return (g_read.length > 0)\n    }\n\n    export function write(str: string) {\n        g_write.push(str)\n    }\n\n    export function read(): string {\n        if (g_read.length)\n            return g_read.shift()\n        return \"\"\n    }\n}\n\n\n/////////////////////\n//#################//\n//##             ##//\n//##  eradio.ts  ##//\n//##             ##//\n//#################//\n/////////////////////\n\nlet RADIOID = \"ID\"\nlet MSGEND = \"#EOM#\"\nlet bsyids: string[] = []\nlet rdymsgs: string[] = []\nlet bsymsgs: string[] = []\n\ntype readhandler = () => void\nlet readHandler: readhandler\n\nradio.onReceivedString(function (msg: string) {\n    // mbit radio buffer size is 19\n    // msg format:\n    // -----------\n    // char 0 :             id length\n    // char 1..n :          id\n    // char (18 - n)..19 :  msg chunk \n\n    let idlen: number = +msg.substr(0, 1)\n    msg = msg.substr(1)\n    let id = msg.substr(0, idlen)\n    msg = msg.substr(idlen)\n    let ix = 0\n    for (; ix < bsyids.length; ix++) {\n        if (id == bsyids[ix]) break\n    }\n    if (ix == bsyids.length) {\n        bsyids.push(id)\n        bsymsgs.push(\"\") // is handled at the end by 'bsymsgs[ix] += msg'\n    }\n    if (msg == MSGEND) { // end of message\nbasic.showIcon(IconNames.Happy)\n        rdymsgs.push(bsymsgs[ix])\n        bsymsgs.removeAt(ix)\n        bsyids.removeAt(ix)\n        if (readHandler) readHandler()\n        return\n    }\n    bsymsgs[ix] += msg\n})\n\nnamespace ERadio {\n\n    export function readMessage(): string {\n        let msg = rdymsgs.shift()\n        return msg\n    }\n\n    export function writeMessage(msg: string) {\n        // mbit radio buffer size is 19\n        // chunk format:\n        // -------------\n        // char 0 :             id length\n        // char 1..n :          id\n        // char (18 - n)..19 :  msg chunk \n\n        let idlen = RADIOID.length\n        let chunk: string\n        let chunklen = 18 - idlen // 19 is mbit radio buffer size\n        do {\n            chunk = msg.substr(0, chunklen)\n            msg = msg.substr(chunklen)\n            radio.sendString(idlen.toString() + RADIOID + chunk)\n            basic.pause(1)\n        } while (msg.length > 0)\n        radio.sendString(RADIOID + MSGEND)\n    }\n\n    // for senders only\n    export function setId(id: string) {\n        RADIOID = id\n    }\n}\n\n\n///////////////////////////\n//#######################//\n//##                   ##//\n//##  greenbox-iot.ts  ##//\n//##                   ##//\n//#######################//\n///////////////////////////\n\nESerial.setPins(\n    DigitalPin.P9,\n    DigitalPin.P12,\n    DigitalPin.P13,\n    DigitalPin.P14,\n    DigitalPin.P15,\n    DigitalPin.P16\n)\n\n// initialize\n\nlet str: string\ndo {\n    if (ESerial.available())\n        str = ESerial.read()\n    basic.pause(1)\n} while (str != \"READY\")\nbasic.showIcon(IconNames.Heart)\n\n// handle messages\n\nreadHandler = () => {\n    let msg = ERadio.readMessage()\n    if (msg.length > 0) {\n        basic.showIcon(IconNames.SmallHeart)\n        ESerial.write(msg)\n        basic.showIcon(IconNames.Heart)\n    }\n}\n","README.md":"","pxt.json":"{\n    \"name\": \"greenbox-iot\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"general\": \"github:etmbit/general#4ea1e3f3224a0692900d0a9e2898a515af73c9a0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1761307275802,"editorVersion":"8.0.17","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n//////////////////////\n//##################//\n//##              ##//\n//##  eserial.ts  ##//\n//##              ##//\n//##################//\n//////////////////////\n\nlet g_init = false\nlet g_read: string[]\nlet g_write: string[]\ng_read = []\ng_write = []\nlet g_read_tmo = 0\nlet g_write_tmo = 0\n\nlet g_tx_dat: DigitalPin\t// tx out data\nlet g_tx_rdy: DigitalPin\t// tx out data valid\nlet g_tx_rcv: DigitalPin\t// tx in  data received\nlet g_rx_dat: DigitalPin\t// rx in  data\nlet g_rx_rdy: DigitalPin\t// rx in  data valid\nlet g_rx_rcv: DigitalPin\t// rx out data received\n\nfunction initESerial() {\n    pins.digitalWritePin(g_tx_rdy, 0)\n    pins.digitalWritePin(g_tx_rdy, 0)\n    pins.digitalWritePin(g_tx_rdy, 0)\n    g_read = []\n    g_write = []\n}\n\nfunction writeChar(char: string) {\n    let ch = char.charCodeAt(0)\n    let pin: number\n    for (let i = 0; i < 8; i++) {\n        pin = (ch & (1 << i))\n        pins.digitalWritePin(g_tx_dat, pin == 0 ? 0 : 1)\n        pins.digitalWritePin(g_tx_rdy, 1)\n        while (!pins.digitalReadPin(g_tx_rcv)) {\n            if (control.millis() > g_write_tmo) { initESerial(); return; }\n        }\n        pins.digitalWritePin(g_tx_rdy, 0)\n        while (pins.digitalReadPin(g_tx_rcv)) {\n            if (control.millis() > g_write_tmo) { initESerial(); return; }\n        }\n    }\n}\n\nfunction readChar(): string {\n    let pin: number\n    let ch = 0\n    for (let i = 0; i < 8; i++) {\n        while (!pins.digitalReadPin(g_rx_rdy)) {\n            if (control.millis() > g_read_tmo) { initESerial(); return \"\"; }\n        }\n        pin = pins.digitalReadPin(g_rx_dat)\n        ch |= (pin << i)\n        pins.digitalWritePin(g_rx_rcv, 1)\n        while (pins.digitalReadPin(g_rx_rdy)) {\n            if (control.millis() > g_read_tmo) { initESerial(); return \"\"; }\n        }\n        pins.digitalWritePin(g_rx_rcv, 0)\n    }\n    let ret = (ch == 0 ? \"\" : String.fromCharCode(ch))\n    return ret\n}\n\n// write strings\nbasic.forever(function () {\n    if (!g_init) return;\n    if (g_write.length > 0) {\n        g_write_tmo = control.millis() + 5000\n        let str = g_write.shift()\n        for (let i = 0; i < str.length; i++) {\n            if (control.millis() > g_write_tmo) { initESerial(); break; }\n            writeChar(str[i])\n        }\n        writeChar(String.fromCharCode(0))\n    }\n})\n\n// read strings\nbasic.forever(function () {\n    if (!g_init) return;\n    let str = \"\"\n    let ch = \"\"\n    if ((pins.digitalReadPin(g_rx_rdy) == 1)) { // available\n        g_read_tmo = control.millis() + 5000\n        do {\n            ch = readChar()\n            str += ch\n        } while (!ch.isEmpty())\n        if (control.millis() <= g_read_tmo)\n            g_read.push(str)\n        str = \"\"\n    }\n})\n\nnamespace ESerial {\n\n    export function setPins(tx_dat: DigitalPin,\n        tx_rdy: DigitalPin,\n        tx_rcv: DigitalPin,\n        rx_dat: DigitalPin,\n        rx_rdy: DigitalPin,\n        rx_rcv: DigitalPin) {\n        g_tx_dat = tx_dat\n        g_tx_rdy = tx_rdy\n        g_tx_rcv = tx_rcv\n        g_rx_dat = rx_dat\n        g_rx_rdy = rx_rdy\n        g_rx_rcv = rx_rcv\n\n        initESerial()\n        g_init = true\n    }\n\n    export function available(): boolean {\n        return (g_read.length > 0)\n    }\n\n    export function write(str: string) {\n        g_write.push(str)\n    }\n\n    export function read(): string {\n        if (g_read.length)\n            return g_read.shift()\n        return \"\"\n    }\n}\n\n\n/////////////////////\n//#################//\n//##             ##//\n//##  eradio.ts  ##//\n//##             ##//\n//#################//\n/////////////////////\n\nlet RADIOID = \"ID\"\nlet MSGEND = \"#EOM#\"\nlet bsyids: string[] = []\nlet rdymsgs: string[] = []\nlet bsymsgs: string[] = []\n\ntype readhandler = () => void\nlet readHandler: readhandler\n\nradio.onReceivedString(function (msg: string) {\n    // mbit radio buffer size is 19\n    // msg format:\n    // -----------\n    // char 0 :             id length\n    // char 1..n :          id\n    // char (18 - n)..19 :  msg chunk \n\n    let idlen: number = +msg.substr(0, 1)\n    msg = msg.substr(1)\n    let id = msg.substr(0, idlen)\n    msg = msg.substr(idlen)\n    let ix = 0\n    for (; ix < bsyids.length; ix++) {\n        if (id == bsyids[ix]) break\n    }\n    if (ix == bsyids.length) {\n        bsyids.push(id)\n        bsymsgs.push(\"\") // is handled at the end by 'bsymsgs[ix] += msg'\n    }\n    if (msg == MSGEND) { // end of message\n        rdymsgs.push(bsymsgs[ix])\n        bsymsgs.removeAt(ix)\n        bsyids.removeAt(ix)\n        if (readHandler) readHandler()\n        return\n    }\n    bsymsgs[ix] += msg\n})\n\nnamespace ERadio {\n\n    export function readMessage(): string {\n        let msg = rdymsgs.shift()\n        return msg\n    }\n\n    export function writeMessage(msg: string) {\n        // mbit radio buffer size is 19\n        // chunk format:\n        // -------------\n        // char 0 :             id length\n        // char 1..n :          id\n        // char (18 - n)..19 :  msg chunk \n\n        let idlen = RADIOID.length\n        let chunk: string\n        let chunklen = 18 - idlen // 19 is mbit radio buffer size\n        do {\n            chunk = msg.substr(0, chunklen)\n            msg = msg.substr(chunklen)\n            radio.sendString(idlen.toString() + RADIOID + chunk)\n            basic.pause(1)\n        } while (msg.length > 0)\n        radio.sendString(idlen.toString() + RADIOID + MSGEND)\n    }\n\n    // for senders only\n    export function setId(id: string) {\n        RADIOID = id\n    }\n}\n\n\n///////////////////////////\n//#######################//\n//##                   ##//\n//##  greenbox-iot.ts  ##//\n//##                   ##//\n//#######################//\n///////////////////////////\n\nESerial.setPins(\n    DigitalPin.P9,\n    DigitalPin.P12,\n    DigitalPin.P13,\n    DigitalPin.P14,\n    DigitalPin.P15,\n    DigitalPin.P16\n)\n\n// initialize\n\nlet RESET = false\n\nrunHandler = () => { // button A pressed\n    RESET = true\n}\n\nlet str: string\ndo {\n    if (ESerial.available())\n        str = ESerial.read() // did RPI startup ?\n    basic.pause(1)\n} while ((str != \"READY\") && !RESET)\nbasic.showIcon(IconNames.Heart)\n\n// handle messages\n\nreadHandler = () => {\n    let msg = ERadio.readMessage()\n    if (msg.length > 0) {\n        basic.showIcon(IconNames.SmallHeart)\n        ESerial.write(msg)\n        basic.showIcon(IconNames.Heart)\n    }\n}\n","README.md":"","pxt.json":"{\n    \"name\": \"greenbox-iot\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"general\": \"github:etmbit/general#4ea1e3f3224a0692900d0a9e2898a515af73c9a0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1761307275822}